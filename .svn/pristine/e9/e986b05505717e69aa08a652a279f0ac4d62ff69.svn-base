Chapitre 1 Clean Code

Avoir un code propre est important. Si celui ci n'est pas lisible ou trop complexe il sera ou inutilisable ou source
lors des mise à jour de l'application.
 
Le code se doit de bien agencé. Si une equipe commence un projet sans se soucier de lisibilité de sa production , sa courbe 
de productivité de sera fortement décroissante avec le temps.

Règle des scouts :"laisser point de capement aussi propre que possible" 
Il en va de même avec le code. 

Chapitre 2 Convention de nommage

Les nom des variable doivent être significativent et poarler d'elle même , dans l'absolu elles etre unique dans chacune des
fichiers dans lequelle elles se trouvent.

Chapitre 3 Fonction

Dans ce chapitre, plusieurs thèmes sont abordés.
- Elles doivent être petite
- Elles doivent faire une seule chose
- Il n'y a qu'un seul niveau d'abstraction dans chaque fonction.
- Il faut utiliser des noms descriptifs
- L'utilisation des switchs, qui de par leurs natures font plusieurs choses.
 Il faut donc les intégrer dans une fonction de bas niveau afin d'éviter qu'elle soit répéter.
- Les arguments des fonctions. Le meilleur cas c'est de n'avoir aucun argument, au maximum il ne faut pas dépasser trois
 sauf dans des cas très spéciaux.
	- Les fonctions qui ne possèdent que un argument, servent en générale à poser une question (par exemple vérifier si un fichier existe)
 ou alors pour transformer un argument (InputStream fileOpen("MyFile") se le String en InputStream)
	- L'utilisation d'argument booleen n'est pas très pratique, car la fonction réalise alors deux choses
l'une quand la condition est vrai et une autre quand elle fausse.
	- Les fonctions qui possèdent deux arguments sont plus compliqé à comprendre
que celles aui ne possèdent qu'un argument. On peut les utiliser lorsau'on définit un point par exemple
- Il faut préférer utiliser des exceptions plutôt que des retours d'erreurs 
- Ne pas se répéter
- Structurer son programme


Chapitre 4 Commentaires

L'utilisation des commentaires est due au manque de claireté du programme, le programme doit pouvoir renvoyer 
votre intention rien que pqr le nom de ses variables, class ou fonctions.
Dans certain cas il y a les commentaires légales, il sont nécéssaire (copyright et autorship).
Les commentaires ont d'autres utilisation tels que la clarification, exprimer les dangers et conséquences.

Les mauvaise utilisations de commentaires sont les commentaires redondant, ceux qui servent à meubler votre code
les commentaires trompeurs qui ne sont pas à jour, lorsque l'on met en commentaire des lignes de code que l'ont à écrit,

Chapitre 5 Le formattage 

Il est important d'avoir  un code structuré pour qu'il puisse etre aisément modifié.

1) Le formatage vertical.
	Le code ne doit pas dépasser un certain nombre de ligne, 
	cela va dépendre du type de fichier manipuler mais pour donner un orbre de grandeur 
	le code ne doit pas dépasser les 500 lignes. Plus le fichier sera petit et concis, 
	plus il sera facile de le lire.
	
2) Les noms
	Les noms des fichiers doivent être ecrit en langage de haut niveau, 
	et decriront parfaitement la fonction des fichier.
	Au sein des fichier les noms de données seront nommé en fonction de leur importance dans la hiérarchie 
	du fichier plus l'on sera bas dans la hiérarchie plus on pourra se permettre de nommer les variables avec
	des noms "abstrait".

3) La séparation des conceptes
	Chaque concepte au sein d'u fichier sera séparé d'un blanc affin de faciliter la lecture et de 
	"chapitrer" le code .
	Ceci permettra de distinguer plus rapidement les différents concepte d'un fichier, par exemple,
	faciliter l'identification des différente méthode dans une classe.

4) La distance vertical 
	Les variables doivent etre déclaré le plus près possible de l'endoit ou elle seront utilisé.
	Cas particulier des variable d'instance,  celles ci  devront toutes etre déclarées au même endroit.
	(En java, elle seront généalement déclaré en haut de la classe)
	Si un focntion ou méthode en appelle une autre elle devront également être proche.

5) L'ordre vertical
	Les fonctions les plus importantes devront être placées le haut possible dans le code source.

6) Le formatage horizontal
	Les ligne ne doivent pas être trop chargées, privilégier les instructions courtes, 
	quitte à devoir séparer l'instruction en deux parties.
7) L'alignement 
	Les données doivent toutes avoir le même alignement.

Important , se mettre d'accord sur nos normes de présentation de code.

Chapitre 6 

Tout d'abord les données doivent être abstraite c'est à dire qu'un étranger lisant le code ne doit pas savoir précisement à quelle utilisation correspond chaque variable pour qu'il ne puisse pas utiliser les accesseurs simplement.
Polypmorphisme ou procédurale : this is the question ?!
Poly -> Square rectangle and circle with calcul méthode inside. Ajouter des classes est donc plus facile mais les fonctions sont tous modifiés.
Procédurale et structure de données-> Square rectangle circle then méthode calcul. Ajouter des fonctions est donc plus simple mais classe plus lourde.
Loi de Démeter : Un modulene doit pas connaitre liens internes des objets manipulés donc les accesseurs des objets vont à l'inverse de se principe
"Ne parlez qu'à vos amis immédiats" Objet A ne peut pas faire appel A B pour connaitre C
Une méthode d'un objet peut appeller :
	Son objet 
	Les paramètres de la méthode 
	Les objets crée ou instancié par la méthode 
	Les objets menbres de sont objets
Avantage -> les objets sont moins dépendants de la structure interne des autres objets
Desavantage -> grand nombre de petites méthodes

DTO -> classe avec variable publique et sans fonction
Beans -> Classe avec variable privé et accesseurs

Chapitre 7 Les exceptions

Dans chaque progamme, il y a des exceptions qui apparaissent suites 
à des entrées anormales ou les appareils peuvent echouer. Le but d'une exception est de permettre au code de continuer à faire ce pourquoi il à été créer.
Cependant ces exceptions doivent être claire, dans certains code la gestion des erreurs
est tellement dispersées qu'il est impossible de voir d'où proviens l'erreur.


L'utilisation de la commande try{} catch(){} finally{}, permet de clarifier le code et de séparer
la gestions des erreurs et l'arret du périphérique. 
Grâce à cette séparation on a la possibilité de lire et comprendre indépendament chaque partie.

Lorsque l'on essaye d'acceder à un fichier inexistant, le test ne génère pas d'exception; 
par contre si l'ont cherche un fichier invalid, on obtiens une exception.
La signature de chaque méthode énumérerait tous les exceptions qu'il 
pourrait transmettre à son appelant. De plus, ces exceptions faisaient partie du type
de la méthode.À l'époque, nous pensions que les exceptions vérifiées étaient une excellente idée; et oui, ils peuvent
donner un certain avantage. Cependant, il est clair maintenant qu'ils ne sont pas nécessaires à la production de
logiciel robuste.

Si l'une des fonctions d'un niveau très bas est modifiée de telle sorte qu'elle doit lancer une exception, on doit ajouter une clause throws à cette dernière.
Mais ça signifie que chaque fonction qui appelle notre fonction doit ajouter une clause throws.
A cause de cela l'encapsulation est interrompu, car chaque fonction doit connaitre les détails de cette exception de bas niveau.


On appelle le modèle de cas spécial [Fowler] lorsque vous créez une classe ou configurez une
objet afin qu'il gère un cas particulier pour vous.


		Ne pas retourner la valeur NULL
Si on veux retourner une valeur NULL, il faut plutôt penser à retourner un objet SPECIAL CASE ou lancer une exception.


Conclusion

Le code propre est lisible, mais il doit aussi être robuste. Ce ne sont pas des objectifs contradictoires. nous pouvons
écrire du code propre robuste si nous considérons que la gestion des erreurs est une préoccupation distincte.

Chapitre 8 :

1) En utilisant un code tiers :

Il est difficile de comprendre un code tiers, mais églament de l'intégrer à notre code à nous. Il faut donc créer
des tests pour comprendre comment fonctionne le code tiers. Ces tests précis et expérimentaux peuvent être
réutilisés si une nouvelle version du code tiers sort, pour savoir s'il y a des différences importantes. Ils 
permettent de savoir si le package que nous utilisons fonctionne comme on le souhaite. Même une fois intégré, il
n'y a aucune garantie que le code tiers reste compatible avec nos attentes. L'auteur peut à tout moment changer son
code, pour ajouter de nouvelles fonctionnalités, fixer des bugs... A chaque mise à jour il y a de nouveaux risques.

2) En utilisant un code qui n'existe pas encore :

On peut faire quelque chose de propre et facilement compréhensible, en utilisant des termes simples et qui montrent
parfaitement à quoi correspond chaque élément.

Chapitre 9 / Les tests unitaires

Lois du TDD (Test Driven Development) :

	Première loi. Vous ne devez pas écrire un code de production tant que vous n’avez pas
écrit un test unitaire d’échec.
	Deuxième loi. Vous devez uniquement écrire le test unitaire suffisant pour échouer ;
l’impossibilité de compiler est un échec.
	Troisième loi. Vous devez uniquement écrire le code de production suffisant pour réussir
le test d’échec courant.
Le code de test est aussi important que le code de production.
La chose la plus importante dans un test : la lisibilité.
Il est primordial de rendre le code lisible et plaisant à lire.
Faire des petits tests une seule fonctionnalitées par test.
F.I.R.S.T :
	Fast : Vite pour lancer les tests rapidement
	Independent : Bah tout est dit pas de test dependant à d'autre test.
	Repeatable (reproductible): Le test doit être executable dans tout les domaines. Donc non-spécifique.
	Self-validating : Retourne true or false.


Chapitre 10 Les Classes

L'ecriture d'une classe commence par la definition d'une liste de variable lui etant propre.
En premier les les constantes, puis les variable de classe (static) et enfin les variables d'instance.
La plupart des methodes et variables d'instance se devront d'être d'eclaré en private affin de les 
protéger le plus possible(sauf cas particlier, exemple test devant faire appelle à certaines fonctions)

Une classe doit être petite. Tout comme les fonctions, les classes doivent aller à l'essencielle.

Les classes doivent avoir peu de variable d'instance, et au moins une d'entre elle doit être utilisé 
dans chaque chaque methode d'instance. Une classe respéctant se principe est dite Uni .

Si un classe est trop grande est que certaine ressource son similaire à une autre, essayer de séparer 
cette classe en deux.


Chapitre 12 

D'après Kent Beck, il y a 4 règles pour réaliser un "design" simple 
elle sont :
	- Execute tous les tests
	- Ne contient pas de duplication
	- Exprime l'intention du programmeur
	- Minimise le nombre de classes et de méthodes
ces 4 règles sont noté dans leurs ordre d'importance.

Règle 1 Faire tous les tests :

Un systeme qui ne peut être vérifié ne devrait pas être déployé.
Si l'on veut rendre nos class testable, il faut que nos class soit petite et unique.
Donc si on s'assure de rendre nos programme testable, nous permettra de créer des bons designs

Regle 2 
La duplication est le principal enemi d'un systemem bien conçu.
Cela represente du travail supplementaire, un risque supplementaire,
et de la complexité inutile. 

Regle 3 
Il est facile d'ecrire un code que nous comprenons puisque au moment où nous l'écrivons
nous comprenons le problème.
À mesure que les systèmes deviennent plus complexes, ils prennent plus de temps pour
un developpeur à le comprendre. Le code doit donc exprimer l'intention de son programmateur.
Pour ça il faut choisir des noms expressifs pour chaque fonctions, méthodes,
et variables. Les tests aussi doivent être expressifs, car le but premier d'un
test est d'agir comme de la documentation. Grâce aux tests une personne
devrait être capable de comprendre rapidement le rôle d'une class.

Regle 4
L'objectif est de garder le systèmes global petit, tout en gardant les fonctions.


Conclusion 
Seule l'experience pourra vous prouver ce aui est écris ici, ce livre 
permet aux developpeurs d,adhérer à de bons principes et modèles.

Chapitre 13 / Concurrence
La concurrence c'est les threads -> Faire des programmes qui s'executent en même temps pour que le resultat soit plus rapide.
Elle améliore les performances lorsqu'il est possbile ôssible de partager les temps d'attente.
Avec thread la structure du programme est très différentes.
Cependant entraine des surcoût en terme de performances et plus de code.
Complexe à mettre en oeuvre.
2 thread emprunte 2 chemins différents (un int en possède 12 870) la quasi-totalité de ces chemins entrainent un résultat correcte cependant d'autre ne le font pas.
Alors pour prévenir ce problème le code de concurrence doit être séparé de tout autre code.
On utilise "synchronized" sur les zones critiques pour être sûr que celle fonctionne bien.

Chapitre 15 / Au coeur de JUnit 
Les tests sont fait dans l'ordre du début puis de la fin du programme.
Toute les conditions doivent être encapsulées 
Des noms de variable claire et non anbigue
